# -*- coding: utf-8 -*-
"""Interpolation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13qEYUy64MmUc3E6q2lI8ECrWgdrXaFM-
"""

import matplotlib.pyplot as plt
import numpy as np
import math

# Tracer la fonction

def f1(x):
    return x - np.cos(x)

x = np.linspace(-0.5, 3, 1000)
y = f1(x)

plt.plot(x, y)
plt.xlabel('x')
plt.ylabel('f1(x)')
plt.title('Graphique de la fonction f1(x) = x-cos(x)')
plt.show()

def point_fixe(g, x0, eps=1e-6, N=1000):
    x = x0
    iters = [0]
    for i in range(N):
        x_prec = x
        x = g(x)
        iters.append(i+1)
        if abs(x - x_prec) < eps:
            return (x, iters)
    return (None, iters)

g = lambda x: np.cos(x) 

x0 = 1
x_star, iters = point_fixe(g, x0)

if x_star is not None:
    print("La solution est:", x_star)
else:
    print("La méthode n'a pas convergé.")

y1 = f1(x)
y2 = g(x)

plt.plot(x, y1, label='f(x)')
plt.plot(x, y2, label='g(x)')
plt.plot([x_star], [f1(x_star)], "ro", label='solution')
plt.legend()
plt.show()

"""# Nouvelle section"""

def point_fixe(g, x0, eps=1e-6, N=1000):
    x = x0
    iters = []
    x_list_error = []
    for i in range(N):
        x_prec = x
        x = g(x)
        iters.append(i)
        x_list_error.append(abs(x - x_prec))

        if abs(x - x_prec) < eps:
            return (x_list_error, iters)

    return (None, iters)

x0 = 0.8
x_star, iters = point_fixe(g, x0)
x_list_error, _ = point_fixe(g, x0)

if x_star is not None:
    print("La solution est:", x_star)
else:
    print("La méthode n'a pas convergé.")


plt.plot(iters, [f1(g(i)) for i in range(len(iters))], label='approximations')
plt.plot([len(iters)-1], [f1(g(len(iters)-1))], 'ro', label='solution')

#Tracer l'erreur en fonction du nombre d'itérations
plt.plot(iters, x_list_error, label='erreurs')
plt.xlabel('Itérations')
plt.ylabel('Erreurs')

plt.legend()
plt.show()

plt.semilogy(iters, x_list_error, label='erreurs')

plt.plot([np.log(abs(x-1)) for x in range(len(x_list_error))], [np.log(abs(x)) for x in range(len(x_list_error))])
plt.xlabel('ln|en|')
plt.ylabel('ln|en+1|')

# Calcul du taux de convergence

for i in range(len(x_list_error)):
  if len(x_list_error) > 2:
      taux_conv = (np.log(abs(x_list_error[i] / x_list_error[i-1])) / np.log(abs(x_list_error[i-1] / x_list_error[i-2])))
      print("Le taux de convergence est :", taux_conv)
  else:
      print("Le nombre d'itérations est insuffisant pour calculer le taux de convergence")

vitesse_conv =[] 

for i in range(len(x_list_error)-2):
    vitesse_conv.append(abs(x_list_error[i+2] - x_list_error[i+1]) / abs(x_list_error[i+1] - x_list_error[i]))

fig, v = plt.subplots()
y= vitesse_conv
v.plot([x for x in range(len(vitesse_conv))],y)
plt.show()